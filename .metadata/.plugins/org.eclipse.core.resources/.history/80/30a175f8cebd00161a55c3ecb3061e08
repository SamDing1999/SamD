package fracCalc;
import java.util.*;
import org.junit.Test;

// Checkpoint 3-only tests
public class FracCalcTestCheckpoint3
{
    @Test public void testCheckpoint3_AdditionSimple3() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "4_3/7", FracCalc.produceAnswer("1_1/7 + 3_2/7"));}
    @Test public void testCheckpoint3_AdditionWholeNumbers2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "1", FracCalc.produceAnswer("2/3 + 1/3"));}
    @Test public void testCheckpoint3_AdditionWholeNumbers7() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "1021778", FracCalc.produceAnswer("124543 + 897235"));}
    @Test public void testCheckpoint3_AdditionWithNegatives4() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "-1_1/4", FracCalc.produceAnswer("-3_3/4 + 2_2/4"));}
    @Test public void testCheckpoint3_AdditionImproperFractionsAndReductions2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "1_1/20", FracCalc.produceAnswer("4/5 + 2/8"));}
    @Test public void testCheckpoint3_AdditionCombined4() { FracCalcTestALL.assertForEarlyCheckpoints(null, null, "62_11/19", FracCalc.produceAnswer("0 + 34_543/19"));}
    @Test public void testCheckpoint3_SubtractionSimple3() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "0", FracCalc.produceAnswer("4_1/2 - 4_1/2"));}
    @Test public void testCheckpoint3_SubtractionWithNegatives3() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "-1_1/4", FracCalc.produceAnswer("-3_3/4 - -2_2/4"));}
    @Test public void testCheckpoint3_SubtractionCombined2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "8_5/21", FracCalc.produceAnswer("-12_3/7 - -20_2/3"));}
    @Test public void testCheckpoint3_MultiplicationBasic1() {  FracCalcTestALL.assertForEarlyCheckpoints(null, null, "3", FracCalc.produceAnswer("1_1/2 * 2"));}
    @Test public void testCheckpoint3_MultiplicationBasic10() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "378/943", FracCalc.produceAnswer("27/41 * 14/23"));}
    @Test public void testCheckpoint3_MultiplicationBasic3() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "164268", FracCalc.produceAnswer("234 * 702"));}
    @Test public void testCheckpoint3_MultiplicationWithNegatives2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "-3", FracCalc.produceAnswer("-12/3 * 2/1"));}
    @Test public void testCheckpoint3_MultiplicationWithNegatives6() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "15_5/7", FracCalc.produceAnswer("-3_2/3 * -4_2/7"));}
    @Test public void testCheckpoint3_MultiplicationByZero2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "0", FracCalc.produceAnswer("0 * 0"));}
    @Test public void testCheckpoint3_MultiplicationByZero3() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "0", FracCalc.produceAnswer("0 * 9321"));}
    @Test public void testCheckpoint3_MultiplicationByZero4() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "0", FracCalc.produceAnswer("0 * -5902"));}
    @Test public void testCheckpoint3_MultiplicationCombined1() {   FracCalcTestALL.assertForEarlyCheckpoints(null, null, "1065_115/168", FracCalc.produceAnswer("-32_75/16 * -27_43/21"));}
    @Test public void testCheckpoint3_MultiplicationCombined2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "-15_67/943", FracCalc.produceAnswer("1_27/41 * -3_140/23"));}
    @Test public void testCheckpoint3_DivisionBasic1() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "9/16", FracCalc.produceAnswer("3/4 / 4/3"));}
    @Test public void testCheckpoint3_DivisionBasic2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "2_1/4", FracCalc.produceAnswer("3/2 / 2/3"));}
    @Test public void testCheckpoint3_DivisionWithNegatives5() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "-2_6/7", FracCalc.produceAnswer("-20 / 7"));}
    @Test public void testCheckpoint3_DivisionWithNegatives6() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "1_13/32", FracCalc.produceAnswer("-3_3/4 / -2_2/3"));}
    @Test public void testCheckpoint3_DivisionWithZero5() { FracCalcTestALL.assertForEarlyCheckpoints(null, null, "0", FracCalc.produceAnswer("0 / 46/27"));}
    @Test public void testCheckpoint3_DivisionWithZero6() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "0", FracCalc.produceAnswer("0/24 / 1/46"));}
    @Test public void testCheckpoint3_DivisionCombined2() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "-2_2/3", FracCalc.produceAnswer("16/4 / -3/2"));}
    @Test public void testCheckpoint3_DivisionCombined3() {FracCalcTestALL.assertForEarlyCheckpoints(null, null, "6_661/5520", FracCalc.produceAnswer("-38_3/72 / -4_82/37"));}



	public static void main (String[] args){
		System.out.println(gcf(-143,7));
		System.out.println("Enter an operation");
		Scanner Input  = new Scanner(System.in);
		String userInput = Input.nextLine();
		while (userInput.equals("quit")!= true){
			String answer = produceAnswer(userInput);
			System.out.println(answer);
			System.out.println("please type next operation");
			userInput = Input.nextLine();
		}
		System.out.println("Press RUN to start over");
	}




	public static String produceAnswer(String Input){
		String[] splitSpaces = Input.split(" ");
		String operator= splitSpaces[1];
		int[] operand1= checkoperand(splitSpaces[0]);
		int[] operand2= checkoperand(splitSpaces[2]);
		int[] improperOperand1=toImproperFrac (operand1);
		int[] improperOperand2=toImproperFrac(operand2);
		System.out.println(Arrays.toString(improperOperand1));
		System.out.println(Arrays.toString(improperOperand2));
		String finalAnswer = performOperations(improperOperand1,improperOperand2,operator);
		return finalAnswer;




	}
	public static int[] checkoperand(String operand){
		String[] partsOfOperand=new String [3];
		int underScore = operand.indexOf("_");
		int slash = operand.indexOf("/");
		if (underScore<0 && slash<0) {
			partsOfOperand[0] = operand;
			partsOfOperand[1] = "0";
			partsOfOperand[2] = "1";
		}else if(underScore<0 && slash>0 ){
			partsOfOperand[0] = "0";
			partsOfOperand[1] = operand.substring(0, slash);
			partsOfOperand[2] = operand.substring(slash+1);
		}else if(underScore>0 && slash>0){
			partsOfOperand[0] = operand.substring(0,underScore);
			partsOfOperand[1]=operand.substring(underScore+1,slash);
			partsOfOperand[2] = operand.substring(slash+1);
		}
		
		int[] finalOperand=new int [3];
		for(int i = 0; i < 3; i++){
			finalOperand[i]= Integer.parseInt(partsOfOperand[i]);
		}
		return finalOperand;




	}




	public static String performOperations(int[] firstOperand,int[] SecondOperand,String operator){
		String answer = "";
		if ( operator.equals("-") ){
			answer = toMixedNum(subtract(firstOperand,SecondOperand));
			}else if(operator.equals("+")){
				answer = toMixedNum((add(firstOperand,SecondOperand)));
			}else if(operator.equals("*")){
				answer = toMixedNum(multiply(firstOperand,SecondOperand));
			}else if(operator.equals("/")){
				answer = toMixedNum(divide(firstOperand,SecondOperand));	
			}
			return answer;
		}




			public static int[] toImproperFrac (int[] operands){
				int[] improperFrac=new int [2];
				if(operands[0]<0){
					 improperFrac[0] = (operands[0]*operands[2])+(operands[1]*-1)	;
					 improperFrac[1] = operands[2];
				}else{
					improperFrac[0] =((operands[0]*operands[2])+operands[1]);
					improperFrac[1]=operands[2];
				}
				return improperFrac;
			}
			public static String toMixedNum(int[] pq){
				String answer;
				int GCF = gcf(pq[0],pq[1]);
				if(GCF!=1){
					pq[0] = pq[0]/GCF;
					pq[1] = pq[1]/GCF;
				}
				if(pq[1]<0){
					pq[1]=Math.abs(pq[1]);
					pq[0]=pq[0]*-1;
				}
				int coefficient = pq[0]/pq[1];
		    	int remainder = pq[0] % pq[1];
		    	if (coefficient<0){
		    		if(remainder==0 && pq[1]==1){
						answer = (Integer.toString(coefficient));
		    		}else if(remainder==0 && pq[1]==-1){
		    			answer = (Integer.toString(coefficient));
		    		}else{
		    		 answer = (coefficient + "_" + Math.abs(remainder) + "/" + Math.abs(pq[1]));
		    		}
		    	}else if(pq[0]%pq[1]==0){
		    		answer=(coefficient+"");
		    		
				}else if(coefficient==0){
					
			    		if(remainder<0 && pq[1]<0){
			    			int newNum = remainder*-1;
			    			int newDenom = pq[1]*-1;
			    			answer=(newNum + "/" + newDenom);
			    		}else{
					answer = (remainder + "/" + pq[1]);
			    		}
				}else if(remainder<0 && pq[1]<0){
		    	    	int newNum = remainder*-1;
		    			int newDenom = pq[1]*-1;
		    			answer=((coefficient + "_" + newNum) + "/" + newDenom);
				
				}else{
						answer = ((coefficient + "_" + remainder) + "/" + pq[1]);
						}
					
		    		
		    	return answer;
			}	
	
			public static int gcf(int a, int b){//determines greatest common factor
			    while(a!=0 && b!=0)
			  {int c = b;
			     b = a%b;
			     a = c;
			  }
			  return Math.abs(a+b);
			}
			public static int[] subtract(int [] operandOne, int [] operandTwo){ 
				int[]almostarray =new int[2];
				int firstNumerator = operandOne[0];
				int firstDenominator = operandOne[1];
				int secondNumerator = operandTwo[0];
				int secondDenominator = operandTwo[1];
				int gcf= firstDenominator * secondDenominator;
				int diffNumerator = ((gcf/firstDenominator) * firstNumerator) - ((gcf/secondDenominator) * secondNumerator);
				almostarray[0] = diffNumerator;
				almostarray[1] = gcf;
				return almostarray;
			}
			public static int[] add(int [] operandOne, int [] operandTwo){ 
				int[]almostarray =new int[2];
				int firstNumerator = operandOne[0];
				int firstDenominator = operandOne[1];
				int secondNumerator = operandTwo[0];
				int secondDenominator = operandTwo[1];
				int gcf= firstDenominator * secondDenominator;
				int sumNumerator = ((gcf/firstDenominator) * firstNumerator) + ((gcf/secondDenominator) * secondNumerator);
				almostarray[0] = sumNumerator;
				almostarray[1] = gcf;
				return almostarray;
			}
			public static int[] multiply (int [] operandOne , int [] operandTwo){ 
				int[]almostarray =new int[2];
				int firstNumerator = operandOne[0];
				int firstDenominator = operandOne[1];
				int secondNumerator = operandTwo[0];
				int secondDenominator = operandTwo[1];
				almostarray[0] = firstNumerator * secondNumerator;
				almostarray[1] = firstDenominator * secondDenominator;
				return almostarray;
			}
			public static int[] divide (int [] operandOne, int [] operandTwo){ 
				int[]almostarray =new int[2];
				int firstNumerator = operandOne[0];
				int firstDenominator = operandOne[1];
				int secondNumerator = operandTwo[1];
				int secondDenominator = operandTwo[0];
				almostarray[0] =firstNumerator * secondNumerator;
				almostarray[1] = firstDenominator * secondDenominator;
				return almostarray;
			}
		}





    


